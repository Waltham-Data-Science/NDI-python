"""
ndi.document - NDI database storage item

The ndi.Document class is the primary method for storing data in the NDI database.
Each document has a specific schema type (e.g., 'base', 'session', 'stimulus').

Important Rules for Creating Documents:
1. Do not provide 'base.id' or 'base.datestamp' manually. These are automatically
   generated by the system to ensure uniqueness and accuracy.
2. Use the document_properties dict to create new versions or copies of documents.
3. When specifying document_type, use the name without '.json' extension.
"""

import json
from copy import deepcopy
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

try:
    import pandas as pd
    HAS_PANDAS = True
except ImportError:
    HAS_PANDAS = False

try:
    from did.document import Document as DIDDocument
except ImportError:
    DIDDocument = None

from .ido import Ido
from .common import PathConstants, timestamp


class Document:
    """NDI document class for database storage.

    The Document object is the primary method for storing data in the NDI database.
    Each document has a specific schema type and contains structured properties.

    Attributes:
        document_properties (dict): The document's data as a nested dictionary.

    Example:
        # Create a new document
        doc = Document('base', **{'base.name': 'my_document'})

        # Access properties
        doc_id = doc.id
        doc_class = doc.doc_class()

        # Set session
        doc = doc.set_session_id('session_12345')
    """

    def __init__(
        self,
        document_type: Union[str, dict, 'Document'] = 'base',
        **kwargs
    ):
        """Create a new NDI document.

        Args:
            document_type: Either:
                - A string document type name (e.g., 'base', 'stimulus')
                - A dict containing document properties (for loading existing)
                - Another Document object (for copying)
                - A DIDDocument object (for conversion, if DID-python is installed)
            **kwargs: Name/value pairs for setting document properties.
                      Property names should be fully qualified (e.g., 'base.name').

        Example:
            doc = Document('base', **{'base.name': 'my_doc'})
            doc = Document(existing_doc.document_properties)
        """
        if isinstance(document_type, dict):
            # Loading from existing properties
            self._document_properties = deepcopy(document_type)
        elif isinstance(document_type, Document):
            # Copy from another Document
            self._document_properties = deepcopy(document_type.document_properties)
        elif DIDDocument is not None and isinstance(document_type, DIDDocument):
            # Convert from DIDDocument
            self._document_properties = deepcopy(document_type.document_properties)
        else:
            # Create new from schema
            self._document_properties = self.read_blank_definition(document_type)

            # Generate new ID and timestamp
            ido = Ido()
            self._document_properties['base']['id'] = ido.id
            self._document_properties['base']['datestamp'] = timestamp()

            # Set additional properties from kwargs
            for key, value in kwargs.items():
                self._set_nested_property(key, value)

    @property
    def document_properties(self) -> dict:
        """The document's properties as a nested dictionary."""
        return self._document_properties

    @property
    def id(self) -> str:
        """Return the document's unique identifier."""
        return self._document_properties.get('base', {}).get('id', '')

    @property
    def session_id(self) -> str:
        """Return the document's session identifier."""
        return self._document_properties.get('base', {}).get('session_id', '')

    def set_session_id(self, session_id: str) -> 'Document':
        """Set the session ID for this document.

        Args:
            session_id: The session identifier to set.

        Returns:
            Self for method chaining.
        """
        self._document_properties['base']['session_id'] = session_id
        return self

    def _set_nested_property(self, path: str, value: Any) -> None:
        """Set a nested property using dot notation.

        Args:
            path: Property path like 'base.name' or 'element.type'.
            value: Value to set.
        """
        parts = path.split('.')
        obj = self._document_properties
        for part in parts[:-1]:
            if part not in obj:
                obj[part] = {}
            obj = obj[part]
        obj[parts[-1]] = value

    def _get_nested_property(self, path: str, default: Any = None) -> Any:
        """Get a nested property using dot notation.

        Args:
            path: Property path like 'base.name'.
            default: Default value if path doesn't exist.

        Returns:
            The property value or default.
        """
        parts = path.split('.')
        obj = self._document_properties
        for part in parts:
            if isinstance(obj, dict) and part in obj:
                obj = obj[part]
            else:
                return default
        return obj

    # === File Management ===

    def has_files(self) -> bool:
        """Check if this document has any associated files.

        Returns:
            True if document has files, False otherwise.
        """
        files = self._document_properties.get('files', {})
        file_info = files.get('file_info', [])
        return bool(file_info)

    def add_file(
        self,
        name: str,
        location: str,
        ingest: Optional[bool] = None,
        delete_original: Optional[bool] = None,
        location_type: Optional[str] = None
    ) -> 'Document':
        """Add a file to this document.

        Args:
            name: The file record name for the document.
            location: File path or URL location.
            ingest: Whether to copy file into database (default: True for files,
                    False for URLs).
            delete_original: Whether to delete original after ingest.
            location_type: 'file', 'url', or 'ndicloud'.

        Returns:
            Self for method chaining.

        Raises:
            ValueError: If name is not in the document's file_list.
        """
        # Check if this document accepts files
        if 'files' not in self._document_properties:
            raise ValueError("This document type does not accept files")

        # Validate name is in file_list
        b, msg, fi_index = self._is_in_file_list(name)
        if not b:
            raise ValueError(msg)

        # Detect location type
        location = location.strip()
        detected_type = 'file'
        if location.lower().startswith(('http://', 'https://')):
            detected_type = 'url'
        elif location.lower().startswith('ndic://'):
            detected_type = 'ndicloud'

        # Set defaults based on location type
        if ingest is None:
            ingest = detected_type == 'file'
        if delete_original is None:
            delete_original = detected_type == 'file'
        if location_type is None:
            location_type = detected_type

        # Generate unique ID for this file location
        uid = Ido().id

        location_info = {
            'delete_original': delete_original,
            'uid': uid,
            'location': location,
            'parameters': '',
            'location_type': location_type,
            'ingest': ingest
        }

        # Add to file_info
        if 'file_info' not in self._document_properties['files']:
            self._document_properties['files']['file_info'] = []

        file_info = self._document_properties['files']['file_info']

        if fi_index is None:
            # New file entry
            file_info.append({
                'name': name,
                'locations': [location_info]
            })
        else:
            # Add location to existing file entry
            file_info[fi_index]['locations'].append(location_info)

        return self

    def remove_file(
        self,
        name: str,
        location: Optional[str] = None
    ) -> 'Document':
        """Remove file information from this document.

        Args:
            name: The file name to remove.
            location: Specific location to remove. If None, removes all locations.

        Returns:
            Self for method chaining.
        """
        b, msg, fi_index = self._is_in_file_list(name)
        if not b:
            raise ValueError(msg)

        if fi_index is None:
            return self  # Nothing to remove

        file_info = self._document_properties['files']['file_info']

        if location is None:
            # Remove entire file entry
            del file_info[fi_index]
        else:
            # Remove specific location
            locations = file_info[fi_index]['locations']
            file_info[fi_index]['locations'] = [
                loc for loc in locations if loc['location'] != location
            ]
            # If no locations left, remove the file entry
            if not file_info[fi_index]['locations']:
                del file_info[fi_index]

        return self

    def _is_in_file_list(self, name: str) -> Tuple[bool, str, Optional[int]]:
        """Check if a file name is valid for this document.

        Returns:
            Tuple of (is_valid, error_message, file_info_index)
        """
        if 'files' not in self._document_properties:
            return False, "This document type does not accept files", None

        files = self._document_properties['files']
        file_list = files.get('file_list', [])

        # Check for numbered file pattern (e.g., 'file_1' matches 'file_#')
        search_name = name
        if '_' in name:
            parts = name.rsplit('_', 1)
            if parts[1].isdigit():
                search_name = parts[0] + '_#'

        # Check if name is in file_list
        if name not in file_list and search_name not in file_list:
            return False, f"File '{name}' is not in this document's file_list", None

        # Find index in file_info if exists
        file_info = files.get('file_info', [])
        for i, fi in enumerate(file_info):
            if fi['name'] == name:
                return True, '', i

        return True, '', None

    def current_file_list(self) -> List[str]:
        """Return list of files currently associated with this document.

        Returns:
            List of file names that have been added to the document.
        """
        if 'files' not in self._document_properties:
            return []
        file_info = self._document_properties['files'].get('file_info', [])
        return [fi['name'] for fi in file_info]

    # === Dependency Management ===

    def dependency(self) -> Tuple[List[str], List[dict]]:
        """Return all dependencies for this document.

        Returns:
            Tuple of (names_list, dependency_structures)
        """
        depends_on = self._document_properties.get('depends_on', [])
        if not depends_on:
            return [], []

        names = [d['name'] for d in depends_on]
        return names, depends_on

    def dependency_value(
        self,
        dependency_name: str,
        error_if_not_found: bool = True
    ) -> Optional[str]:
        """Get the value of a dependency by name.

        Args:
            dependency_name: The name of the dependency.
            error_if_not_found: If True, raise error if not found.

        Returns:
            The dependency value (document ID), or None if not found.

        Raises:
            KeyError: If dependency not found and error_if_not_found is True.
        """
        depends_on = self._document_properties.get('depends_on', [])

        for dep in depends_on:
            if dep['name'].lower() == dependency_name.lower():
                return dep['value']

        if error_if_not_found:
            raise KeyError(f"Dependency '{dependency_name}' not found")
        return None

    def dependency_value_n(
        self,
        dependency_name: str,
        error_if_not_found: bool = True
    ) -> List[str]:
        """Get values from a numbered dependency list.

        For dependencies like 'element_1', 'element_2', etc.

        Args:
            dependency_name: Base name (e.g., 'element' for 'element_1', 'element_2').
            error_if_not_found: If True, raise error if no matches found.

        Returns:
            List of dependency values in order.
        """
        depends_on = self._document_properties.get('depends_on', [])
        values = []
        i = 1
        while True:
            found = False
            for dep in depends_on:
                if dep['name'].lower() == f"{dependency_name}_{i}".lower():
                    values.append(dep['value'])
                    found = True
                    break
            if not found:
                break
            i += 1

        if not values and error_if_not_found:
            raise KeyError(f"No dependencies matching '{dependency_name}_*' found")
        return values

    def set_dependency_value(
        self,
        dependency_name: str,
        value: str,
        error_if_not_found: bool = True
    ) -> 'Document':
        """Set the value of a dependency.

        Args:
            dependency_name: The dependency name.
            value: The dependency value (document ID).
            error_if_not_found: If True and dependency doesn't exist, raise error.
                               If False, add the dependency.

        Returns:
            Self for method chaining.
        """
        if 'depends_on' not in self._document_properties:
            if error_if_not_found:
                raise KeyError("Document has no dependencies")
            self._document_properties['depends_on'] = []

        depends_on = self._document_properties['depends_on']

        # Try to find existing
        for dep in depends_on:
            if dep['name'].lower() == dependency_name.lower():
                dep['value'] = value
                return self

        # Not found
        if error_if_not_found:
            raise KeyError(f"Dependency '{dependency_name}' not found")

        # Add new dependency
        depends_on.append({'name': dependency_name, 'value': value})
        return self

    def add_dependency_value_n(
        self,
        dependency_name: str,
        value: str
    ) -> 'Document':
        """Add a value to a numbered dependency list.

        Args:
            dependency_name: Base name (will create 'name_N' where N is next number).
            value: The dependency value to add.

        Returns:
            Self for method chaining.
        """
        existing = self.dependency_value_n(dependency_name, error_if_not_found=False)
        new_name = f"{dependency_name}_{len(existing) + 1}"
        return self.set_dependency_value(new_name, value, error_if_not_found=False)

    # === Document Class Information ===

    def doc_class(self) -> str:
        """Get the document class type.

        Returns:
            The class name (e.g., 'base', 'element', 'stimulus').
        """
        return self._document_properties.get('document_class', {}).get('class_name', '')

    def doc_superclass(self) -> List[str]:
        """Get the document's superclasses.

        Returns:
            List of superclass names.
        """
        doc_class = self._document_properties.get('document_class', {})
        superclasses = doc_class.get('superclasses', [])

        sc_names = []
        for sc in superclasses:
            # Each superclass has a 'definition' pointing to its JSON
            # We need to read that to get the class_name
            definition = sc.get('definition', '')
            if definition:
                try:
                    sc_doc = Document(definition.replace('$NDIDOCUMENTPATH/', '').replace('.json', ''))
                    sc_names.append(sc_doc.doc_class())
                except Exception:
                    pass

        return list(set(sc_names))

    def doc_isa(self, document_class: str) -> bool:
        """Check if this document is of a specific class or inherits from it.

        Args:
            document_class: The class name to check.

        Returns:
            True if document is or inherits from the specified class.
        """
        all_classes = [self.doc_class()] + self.doc_superclass()
        return document_class in all_classes

    def write(self, filename: str, indent: int = 2) -> None:
        """Write document to a JSON file.

        Args:
            filename: Path to write the JSON file.
            indent: Indentation level for pretty printing.
        """
        from pathlib import Path
        Path(filename).parent.mkdir(parents=True, exist_ok=True)
        with open(filename, 'w') as f:
            json.dump(self._document_properties, f, indent=indent)

    def remove_dependency_value_n(
        self,
        dependency_name: str,
        index: Optional[int] = None,
    ) -> 'Document':
        """Remove a numbered dependency value.

        If index is None, removes all dependencies matching the base name.
        Otherwise removes the specific indexed dependency.

        Args:
            dependency_name: Base dependency name.
            index: Optional 1-based index to remove.

        Returns:
            Self for method chaining.
        """
        if 'depends_on' not in self._document_properties:
            return self

        depends_on = self._document_properties['depends_on']

        if index is not None:
            target = f"{dependency_name}_{index}"
            self._document_properties['depends_on'] = [
                d for d in depends_on
                if d['name'] != target
            ]
        else:
            # Remove all matching the pattern
            import re
            pattern = re.compile(rf'^{re.escape(dependency_name)}_\d+$')
            self._document_properties['depends_on'] = [
                d for d in depends_on
                if not pattern.match(d['name'])
            ]

        return self

    # === Comparison and Merging ===

    def __eq__(self, other: 'Document') -> bool:
        """Check equality based on document ID."""
        if not isinstance(other, Document):
            return False
        return self.id == other.id

    def __add__(self, other: 'Document') -> 'Document':
        """Merge two documents.

        The result has fields from both documents. Fields in self take
        precedence over fields in other for conflicts.

        Returns:
            New Document with merged properties.
        """
        result = Document(self._document_properties)

        # Merge superclasses
        my_sc = result._document_properties.get('document_class', {}).get('superclasses', [])
        other_sc = other._document_properties.get('document_class', {}).get('superclasses', [])
        result._document_properties['document_class']['superclasses'] = my_sc + other_sc

        # Merge dependencies
        if 'depends_on' in other._document_properties:
            if 'depends_on' not in result._document_properties:
                result._document_properties['depends_on'] = []
            for dep in other._document_properties['depends_on']:
                existing = [d for d in result._document_properties['depends_on']
                            if d['name'] == dep['name']]
                if existing:
                    existing[0]['value'] = dep['value']
                else:
                    result._document_properties['depends_on'].append(dep)

        # Merge file_list
        if 'files' in other._document_properties:
            if 'files' not in result._document_properties:
                result._document_properties['files'] = other._document_properties['files']
            else:
                my_files = result._document_properties['files'].get('file_list', [])
                other_files = other._document_properties['files'].get('file_list', [])
                result._document_properties['files']['file_list'] = list(set(my_files + other_files))

        # Merge other fields (other's fields added if not in self)
        for key, value in other._document_properties.items():
            if key not in ['document_class', 'depends_on', 'files', 'base']:
                if key not in result._document_properties:
                    result._document_properties[key] = deepcopy(value)

        return result

    # === Conversion ===

    def to_table(self) -> 'pd.DataFrame':
        """Convert document to a pandas DataFrame.

        Returns:
            DataFrame with document properties as columns.

        Raises:
            ImportError: If pandas is not installed.
        """
        if not HAS_PANDAS:
            raise ImportError("pandas is required for to_table()")

        data = {}

        # Add dependencies
        names, deps = self.dependency()
        for dep in deps:
            data[f"depends_on_{dep['name']}"] = dep['value']

        # Flatten properties (excluding files and depends_on)
        def flatten(obj, prefix=''):
            for key, value in obj.items():
                if key in ['depends_on', 'files']:
                    continue
                full_key = f"{prefix}{key}" if prefix else key
                if isinstance(value, dict):
                    flatten(value, f"{full_key}.")
                else:
                    data[full_key] = value

        flatten(self._document_properties)

        return pd.DataFrame([data])

    def to_dict(self) -> dict:
        """Convert document to a plain dictionary.

        Returns:
            Copy of document_properties.
        """
        return deepcopy(self._document_properties)

    def to_json(self, indent: int = 2) -> str:
        """Convert document to JSON string.

        Args:
            indent: Indentation level for pretty printing.

        Returns:
            JSON string representation.
        """
        return json.dumps(self._document_properties, indent=indent)

    def setproperties(self, **kwargs) -> 'Document':
        """Set multiple properties at once.

        Args:
            **kwargs: Property paths and values (e.g., base_name='test').
                      Underscores are converted to dots for nested access.

        Returns:
            Self for method chaining.

        Example:
            doc.setproperties(**{'base.name': 'new_name', 'element.type': 'probe'})
        """
        for key, value in kwargs.items():
            self._set_nested_property(key, value)
        return self

    def validate(self, session=None):
        """Validate document against its schema.

        Three-tier validation:
          1. This-class properties: type checking against schema
          2. Superclass properties: walk hierarchy
          3. Dependency references: check depends_on targets exist

        Args:
            session: Optional session for dependency checking.

        Returns:
            ValidationResult with is_valid flag and error details.
            Bool-coercible: ``if doc.validate(): ...``
        """
        from .validate import validate as _validate
        return _validate(self, session=session)

    # === Static Methods ===

    @staticmethod
    def find_doc_by_id(
        doc_array: List['Document'],
        doc_id: str
    ) -> Tuple[Optional['Document'], Optional[int]]:
        """Find a document in a list by its ID.

        Args:
            doc_array: List of Document objects.
            doc_id: The ID to search for.

        Returns:
            Tuple of (document, index) or (None, None) if not found.
        """
        for i, doc in enumerate(doc_array):
            if doc.id == doc_id:
                return doc, i
        return None, None

    @staticmethod
    def find_newest(doc_array: List['Document']) -> Tuple['Document', int, datetime]:
        """Find the newest document in a list.

        Args:
            doc_array: List of Document objects.

        Returns:
            Tuple of (newest_document, index, datestamp).
        """
        if not doc_array:
            raise ValueError("Document array is empty")

        timestamps = []
        for doc in doc_array:
            ds = doc._document_properties.get('base', {}).get('datestamp', '')
            if ds:
                # Parse ISO format timestamp
                try:
                    ts = datetime.fromisoformat(ds.replace('Z', '+00:00'))
                except ValueError:
                    ts = datetime.min.replace(tzinfo=timezone.utc)
            else:
                ts = datetime.min.replace(tzinfo=timezone.utc)
            timestamps.append(ts)

        newest_idx = max(range(len(timestamps)), key=lambda i: timestamps[i])
        return doc_array[newest_idx], newest_idx, timestamps[newest_idx]

    @staticmethod
    def read_blank_definition(document_type: str) -> dict:
        """Read a blank document definition from JSON schema.

        Args:
            document_type: The document type name (without .json extension).

        Returns:
            Dictionary with blank document structure.
        """
        # Try to find the JSON definition
        json_path = PathConstants.DOCUMENT_PATH / f"{document_type}.json"

        if not json_path.exists():
            # Try without path constants (for testing)
            raise FileNotFoundError(
                f"Document definition not found: {json_path}. "
                f"Make sure NDI is properly installed."
            )

        with open(json_path, 'r') as f:
            definition = json.load(f)

        # Process superclasses recursively
        if 'document_class' in definition and 'superclasses' in definition['document_class']:
            for sc in definition['document_class']['superclasses']:
                sc_def = sc.get('definition', '')
                if sc_def:
                    # Extract document type from definition path
                    sc_type = sc_def.replace('$NDIDOCUMENTPATH/', '').replace('.json', '')
                    try:
                        sc_props = Document.read_blank_definition(sc_type)
                        # Merge superclass properties
                        for key, value in sc_props.items():
                            if key != 'document_class' and key not in definition:
                                definition[key] = value
                    except FileNotFoundError:
                        pass  # Skip missing superclass definitions

        return definition

    def __repr__(self) -> str:
        return f"Document('{self.doc_class()}', id='{self.id}')"
